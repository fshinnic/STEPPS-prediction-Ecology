library(plyr)
source('r/utils/pred_helper_funs.r')
######################################################################################################################################
# user defs
######################################################################################################################################
# us albers shape file
#us.shp <- readOGR('data/map/us_alb.shp', 'us_alb')
us.shp <- sf::st_read('data/map/us/us_alb.shp', 'us_alb')
# reconstruction limits and bin-width
int  = 100
tmin = 150
if (one_time) {
tmin = tmin + (slice-1)*int
tmax = tmin + int
} else {
tmax = tmin + 20*int
}
# rescale
rescale = 1e6
# suffix to append to figure names
#HO - I have no idea where grid_specs comes from so I will add my own to get it to run.
grid_specs = "test_grid_specs"
suff    = paste(grid_specs, '_', version, sep='')
# specify states; relict from testing
states_pol = c('minnesota', 'wisconsin', 'michigan:north')
states_pls = c('minnesota', 'wisconsin', 'michigan:north')
# specify the taxa to use
# must be from the list: taxa_sub = c('oak', 'pine', 'maple', 'birch', 'tamarack', 'beeh', 'elm', 'spruce', 'ash', 'hemlock')
# always have: 'other.hardwood' and 'other.conifer'
taxa_all = toupper(c('oak', 'pine', 'maple', 'birch', 'tamarack', 'beech', 'elm', 'spruce', 'ash', 'hemlock'))
taxa_sub = toupper(c('oak', 'pine', 'maple', 'birch', 'tamarack', 'beech', 'elm', 'spruce', 'ash', 'hemlock'))
# K is number of taxa
K = as.integer(length(taxa_sub) + 1)
W = K-1
##########################################################################################################################
## paths and filenames to write to meta file
##########################################################################################################################
suff_veg = paste0('12taxa_6341cells_', nknots, 'knots')
path_grid = 'data/grid/umw_3by_v2.rdata'
path_pls      = 'data/pls_umw_v0.6.csv'
path_pollen   = 'data/sediment_ages_v1.0_varves.csv'
# Only non-varve lakes of interest
#path_pollen = 'data/fs_data/wisc_nonvarve_pollen_ts.csv'
if (bchron){
path_age_samples    = 'data/bchron_ages'
} else {
path_age_samples    = 'data/bacon_ages'
}
path_cal      = paste0('data/calibration/', runs[[1]]$suff_fit,'.csv')
path_veg_data = paste0('data/veg_data_', suff_veg, '_v0.4.rdata')
# path_veg_pars = paste0('data/', suff_veg, '_nb_v0.5/veg_pars_', nknots, 'knots.rdata') #HO -This is not a file or directory that exists. Replacing with what I think is correct
path_veg_pars = 'data/veg_pars_120knots.rdata'
##########################################################################################################################
## read in tables and data
##########################################################################################################################
# conversion tables
tree_type = read.table('data/assign_HW_CON.csv', sep=',', row.names=1, header=TRUE)
convert   = read.table('data/dict-comp2stepps.csv', sep=',', row.names=1, header=TRUE)
# pls veg data
pls.raw = data.frame(read.table(file=path_pls, sep=",", row.names=1, header=TRUE))
# read in grid
#load(file=path_grid)
# pollen data
pollen_ts = read.table(path_pollen, header=TRUE, sep=',', stringsAsFactors=FALSE)
# FS - each lake has unique id and multiple bacon_draw#
pol_ids = data.frame(id=unique(pollen_ts$id), stat_id=seq(1, length(unique(pollen_ts$id))))
# if draw=TRUE then replace mean age_bacon with draw age_bacon
if (draw) {
all_files   = list.files(path_age_samples)
all_drawRDS = all_files[grep('draw', all_files)]
# FS - randomply choses one draw index
drawRDS     = all_drawRDS[sample(seq(1, length(all_drawRDS)), 1)]   # random sample from available posterior age draws
age_sample   = readRDS(file.path(path_age_samples, drawRDS))
# replace age_bacon with the draw
if (bchron){
pollen_ts$age_bchron = age_sample
} else {
pollen_ts$age_bacon  = age_sample
}
}
if (bchron){
pollen_ts = pollen_ts[!is.na(pollen_ts$age_bchron),]
} else {
pollen_ts = pollen_ts[!is.na(pollen_ts$age_bacon),]
}
# max_ages
if (constrain){
if (bchron){
max_ages = read.table(file='data/pol_ages_bchron_6.csv', sep=',', header=TRUE)
} else {
max_ages = read.table(file='data/pol_ages_v6.csv', sep=',', header=TRUE)
}
drop_samples = constrain_pollen(pollen_ts, max_ages, nbeyond=nbeyond)
if (add_varves){
vids = c(2309, 14839, 3131)
drop_samples[which(pollen_ts$id %in% vids)] = FALSE
}
pollen_ts = pollen_ts[!drop_samples,]
}
cal_fit = rstan::read_stan_csv(path_cal)
# read in veg data and output
# veg data specifies which knots to use
load(path_veg_data)
veg_post = readRDS(file=path_veg_pars)
# load(file=path_veg_pars)
# veg_post = post
##########################################################################################################################
## read in and organize pls data
##########################################################################################################################
# changes taxa names to lower case
colnames(pls.raw) = tolower(colnames(pls.raw))
# pull the subset of proportions
taxa.start.col = min(match(tolower(rownames(convert)), colnames(pls.raw)), na.rm=TRUE)
# # might need to fix this later, doesn't work with updated data but don't need it now
# if (any(!(tolower(sort(taxa)) == sort(colnames(pls_dat))))) {
#   pls_dat  = pls.raw[,taxa.start.col:ncol(pls.raw)]
#   colnames(pls_dat) = as.vector(convert[match(colnames(pls_dat), tolower(rownames(convert))),1])
#   pls_dat_collapse  = sapply(unique(colnames(pls_dat)),
#                              function(x) rowSums( pls_dat[ , grep(x, names(pls_dat)), drop=FALSE]) )
#   counts = data.frame(pls_dat_collapse[,sort(colnames(pls_dat_collapse))])
# }
# FS - raw pollen couts for each taxa
counts = pls.raw[,taxa.start.col:ncol(pls.raw)]
# FS - geographical location of each count
meta   = pls.raw[,1:(taxa.start.col-1)]
# kilometers
# pls$X = pls$X/1000
# pls$Y = pls$Y/1000
# FS - use the new function
# create collumns state (minnesota, south dakatoa, north dakota, iowa, na, wiconsin, michigan:north, illinois, michigan:south, indiana, ohio)
# and state2 (minnesota, wisconsin, michigan:north, and michigan:south) the corrected map look up
meta        = split_mi(meta)
c
load("~/Documents/STEPPS-prediction-Ecology/debugging/split_mi_2060.RData")
meta
# FS - use the new function
# create collumns state (minnesota, south dakatoa, north dakota, iowa, na, wiconsin, michigan:north, illinois, michigan:south, indiana, ohio)
# and state2 (minnesota, wisconsin, michigan:north, and michigan:south) the corrected map look up
meta        = split_mi(meta)
# only keep counts/meta that are in the corrected "minnesota" "wisconsin" "michigan:north" (states_pls)
counts      = counts[which(meta$state2 %in% states_pls),]
meta        = meta[which(meta$state2 %in% states_pls),]
centers_pls = data.frame(x=meta$x, y=meta$y)/rescale # megameters!
# FS - Corrected for SP object; checks that seperated out the correct uppermidwest cells
# plot(centers_pls[,1]*rescale, centers_pls[,2]*rescale, asp=1, axes=F,  col='antiquewhite4', xlab='',ylab='', pch=19, cex=0.2) # old code
# plot(us.shp, add=T) # old code
# plots center of pls grid cells (8 km x 8 km)
plot(centers_pls[,1] * rescale,
centers_pls[,2] * rescale,
asp = 1,
axes = FALSE,
col = "antiquewhite4",
pch = 19,
cex = 0.2)
# adds borders
plot(st_geometry(us.shp), add = TRUE, border = "black", lwd = 0.5)
# FS - aggreg raw pollen count data into 12 taxa (including OTHER group)
y_veg = convert_counts(counts, tree_type, taxa_sub)
# FS - aggreg raw pollen count data into 12 taxa (including OTHER group)
y_veg = convert_counts(counts, tree_type, taxa_sub)
# FS - removes collumn names, creating counts as ordered matrix
taxa = colnames(y_veg)
y_veg = as.matrix(round(unname(y_veg)))
rownames(y_veg) = NULL
y_veg = unname(y_veg)
K = as.integer(ncol(y_veg))
W = K-1
N_pls = nrow(y_veg)
# FS - created domain of uppermidwest form PLS grid centers
states_pls <- c("wisconsin", "michigan:north","minnesota")
domain <- meta[meta$state2 %in% states_pls, c("x", "y")]
# FIXME: ADD STATE TO GRID
# coarse_domain  = coarse_domain[coarse_domain$state %in% states_pls,]
coarse_centers = domain[,1:2]
# check domain working with
plot(coarse_centers[,1] * rescale,
coarse_centers[,2] * rescale,
col = "blue",
pch = 19,
cex = 0.3,
asp = 1,
axes = FALSE,
xlab = "",
ylab = "")
plot(st_geometry(us.shp), add = TRUE, border = "black")
# assign grid to centers_veg
centers_veg = coarse_centers
N = nrow(centers_veg)
# subdomain boundaries
xlo = min(centers_veg$x)
xhi = max(centers_veg$x)
ylo = min(centers_veg$y)
yhi = max(centers_veg$y)
# set tamarack to 0 at tamarack creek; see Dawson et al. QSR 2016
pollen_ts[pollen_ts$id == 2624, 'TAMARACK'] = rep(0, sum(pollen_ts$id == 2624))
saveRDS(pollen_ts, file='data/pollen_ts.RDS')
# FS - only keep sites in "minnesota"      "wisconsin"      "michigan:north"
pollen_ts1 = pollen_ts[which(pollen_ts$state %in% states_pol),]
colnames(pollen_ts1)
# FS - had to edit this function to use sf instead
# reproject pollen coords from lat long to Albers
pollen_ts2 = pollen_to_albers(pollen_ts1)
pollen_to_albers <- function(pollen_ts) {
library(sp)
# Remove rows with missing coordinates
pollen_ts <- pollen_ts[!is.na(pollen_ts$lat) & !is.na(pollen_ts$long), ]
if(nrow(pollen_ts) == 0) stop("No valid coordinates to transform.")
centers_pol <- data.frame(x = pollen_ts$long, y = pollen_ts$lat)
coordinates(centers_pol) <- ~ x + y
proj4string(centers_pol) <- CRS("+proj=longlat +datum=WGS84 +no_defs")
centers_polA <- spTransform(centers_pol, CRS(SRS_string = "EPSG:3175"))
centers_polA_df <- as.data.frame(centers_polA)
colnames(centers_polA_df) <- c("x", "y")
pollen_ts$x <- centers_polA_df$x
pollen_ts$y <- centers_polA_df$y
return(pollen_ts)
}
# FS - had to edit this function to use sf instead
# reproject pollen coords from lat long to Albers
pollen_ts2 = pollen_to_albers(pollen_ts1)
pollen_ts2
# FS - location of pollen
pollen_locs = cbind(pollen_ts2$x, pollen_ts2$y)
# FS - checks that the pollen sitees are within the vegetation domain
plot(centers_veg$x, centers_veg$y, col='green', pch=19, main='Vegetation vs Pollen')
points(pollen_locs[,1], pollen_locs[,2], col='red', pch=19)
# FS - FIX ME - currently no matches ie no cores in the domain
#pollen_int  = cores_near_domain(pollen_locs, centers_veg, cell_width = res*8000/rescale)
cell_width_value <- 8000   #  FS - changed!!!!
pollen_int <- cores_near_domain(pollen_locs, centers_veg, cell_width = cell_width_value)
pollen_int
# FS - Keep only pollen points that exactly match the coordinates in pollen_int
# FS - idx_pollen_int is a logical vector used to filter pollen_ts2 to these points
idx_pollen_int = apply(pollen_locs, 1,
function(x) if (any(rdist(x, pollen_int) < 1e-8)) {return(TRUE)} else {return(FALSE)})
pollen_ts3 = pollen_ts2[idx_pollen_int, ]
# plot domain and core locations
par(mfrow=c(1,1))
plot(centers_veg$x*rescale, centers_veg$y*rescale)
points(pollen_ts3$x*rescale, pollen_ts3$y*rescale, col='blue', pch=19)
plot(us.shp, add=T, lwd=2)
build_pollen_counts
# sum counts over int length intervals
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
pollen_agg
build_pollen_counts
tmin
tmax
int
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
counts     = pollen_agg[[1]]
counts
colnames(counts)
pollen_agg
build_pollen_counts
meta_pol$stat_id = pol_ids$stat_id[match(meta_pol$id, pol_ids$id)]
meta_pol_all$stat_id = pol_ids$stat_id[match(meta_pol_all$id, pol_ids$id)]
pollen_ts$stat_id = pol_ids$stat[match(pollen_ts$id, pol_ids$id)]
pollen_ts
unique(pollen_ts$stat_id)
ages    = unique(sort(meta_pol$age))
ages
T       = length(ages)
if (one_time) {
lag = 0
} else {
lag     = unname(as.matrix(dist(matrix(ages), upper=TRUE)))
}
lag
N_cores = length(unique(meta_pol$id))
N_cores
y = convert_counts(counts, tree_type, taxa_sub)
convert_counts
y
convert_counts
# make sure columns match!
if (sum(colnames(y) %in% taxa) != K){
print('The number of taxa wanted does not match the number of taxa in the data frame! Name mismatch likely.')
}
# y = y[,taxa]
y = unname(y)
y
centers_pol = data.frame(x=numeric(N_cores), y=numeric(N_cores))
centers_pol
N_cores
N_cores
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
unique(meta_pol$id)[i]
min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
c(meta_pol$x[idx], meta_pol$y[idx])
meta_pol$x[idx]
meta_pol
centers_veg
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$lat[idx], meta_pol$long[idx])   # FS - changed x to lat and y to long
}
build_idx_cores
# indices for which cells the cores fall in
idx_cores <- build_idx_cores(centers_pol, centers_veg, N_cores)
plot(centers_veg$x*rescale, centers_veg$y*rescale, col='lightgrey')
points(centers_veg[idx_cores,'x']*rescale, centers_veg[idx_cores,'y']*rescale, col='red', pch=19)
points(centers_pol$x*rescale, centers_pol$y*rescale, col='blue', pch=4, cex=1.4)
plot(us.shp, add=TRUE)
convert_counts
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
counts     = pollen_agg[[1]]
meta_pol$stat_id = pol_ids$stat_id[match(meta_pol$id, pol_ids$id)]
meta_pol_all$stat_id = pol_ids$stat_id[match(meta_pol_all$id, pol_ids$id)]
pollen_ts$stat_id = pol_ids$stat[match(pollen_ts$id, pol_ids$id)]
ages    = unique(sort(meta_pol$age)) # FS - only 21, each = 100 years
T       = length(ages)
if (one_time) {
lag = 0
} else {
lag     = unname(as.matrix(dist(matrix(ages), upper=TRUE)))
}
N_cores = length(unique(meta_pol$id)) # FS - 199
y = convert_counts(counts, tree_type, taxa_sub)
# make sure columns match!
if (sum(colnames(y) %in% taxa) != K){
print('The number of taxa wanted does not match the number of taxa in the data frame! Name mismatch likely.')
}
# y = y[,taxa]
y = unname(y)
centers_pol = data.frame(x=numeric(N_cores), y=numeric(N_cores))
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$lat[idx], meta_pol$long[idx])   # FS - changed x to lat and y to long
}
# some are duplicates, but we still need them as separate rows!
# centers_pol <- meta_pol[!duplicated(cbind(meta_pol$x, meta_pol$y)), c('x', 'y')]
# indices for which cells the cores fall in
idx_cores <- build_idx_cores(centers_pol, centers_veg, N_cores)
plot(centers_veg$x*rescale, centers_veg$y*rescale, col='lightgrey')
points(centers_veg[idx_cores,'x']*rescale, centers_veg[idx_cores,'y']*rescale, col='red', pch=19)
points(centers_pol$x*rescale, centers_pol$y*rescale, col='blue', pch=4, cex=1.4)
plot(us.shp, add=TRUE)
# check domain splitting
idx_cores_all <- build_idx_cores(cbind(pollen_check$x, pollen_check$y), centers_veg, N_cores=nrow(pollen_check))
pol_ids$c
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
build_pollen_counts
pollen_ts3
pollen_ts3$x
pollen_ts3$y
##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - START HERE 12/26/2025
# sum counts over int length intervals
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
counts     = pollen_agg[[1]]
meta_pol$stat_id = pol_ids$stat_id[match(meta_pol$id, pol_ids$id)]
meta_pol_all$stat_id = pol_ids$stat_id[match(meta_pol_all$id, pol_ids$id)]
pollen_ts$stat_id = pol_ids$stat[match(pollen_ts$id, pol_ids$id)]
ages    = unique(sort(meta_pol$age)) # FS - only 21, each = 100 years
T       = length(ages)
if (one_time) {
lag = 0
} else {
lag     = unname(as.matrix(dist(matrix(ages), upper=TRUE)))
}
N_cores = length(unique(meta_pol$id)) # FS - 199
y = convert_counts(counts, tree_type, taxa_sub)
# make sure columns match!
if (sum(colnames(y) %in% taxa) != K){
print('The number of taxa wanted does not match the number of taxa in the data frame! Name mismatch likely.')
}
# y = y[,taxa]
y = unname(y)
centers_pol = data.frame(x=numeric(N_cores), y=numeric(N_cores))
centers_pol
(
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
centers_pol
centers_pol
c(meta_pol$x[idx], meta_pol$y[idx])
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
idx
N_cores
idx
meta_pol$x[idx]
meta_pol$y[idx]
meta_pol$x
pollen_agg
pollen_agg$x
pollen_agg$lat
meta_pol$lat
pollen_ts3$y
##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - START HERE 12/26/2025
meta_cols = c("id", "x", "y", "state", "site", "something_else")  # first 6 columns
pollen_ts3 = pollen_ts3[, c(meta_cols, taxa_all)]
colnames(pollen_agg)
pollen_agg
colnames(pollen_ts3)
pollen_ts3
pollen_agg
build_pollen_counts
build_pollen_counts
##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - START HERE 12/26/2025
pollen_ts3 <- pollen_ts3[, c("id", "x", "y", setdiff(colnames(pollen_ts3), c("id","x","y")))]
pollen_ts3
taxa.start.col <- min(match(taxa_all, colnames(pollen_ts3)), na.rm=TRUE)
colnames(pollen_ts3)[1:(taxa.start.col-1)]
##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - START HERE 12/26/2025
# FS - Moved x and y columns to front so that they aren't lost in build_pollen_counts function
pollen_ts3 <- pollen_ts3[, c("id", "x", "y", setdiff(colnames(pollen_ts3), c("id","x","y")))]
# sum counts over int length intervals
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
counts     = pollen_agg[[1]]
meta_pol$stat_id = pol_ids$stat_id[match(meta_pol$id, pol_ids$id)]
meta_pol_all$stat_id = pol_ids$stat_id[match(meta_pol_all$id, pol_ids$id)]
pollen_ts$stat_id = pol_ids$stat[match(pollen_ts$id, pol_ids$id)]
ages    = unique(sort(meta_pol$age)) # FS - only 21, each = 100 years
T       = length(ages)
if (one_time) {
lag = 0
} else {
lag     = unname(as.matrix(dist(matrix(ages), upper=TRUE)))
}
N_cores = length(unique(meta_pol$id)) # FS - 199
y = convert_counts(counts, tree_type, taxa_sub)
# make sure columns match!
if (sum(colnames(y) %in% taxa) != K){
print('The number of taxa wanted does not match the number of taxa in the data frame! Name mismatch likely.')
}
# y = y[,taxa]
y = unname(y)
centers_pol = data.frame(x=numeric(N_cores), y=numeric(N_cores))
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
# indices for which cells the cores fall in
idx_cores <- build_idx_cores(centers_pol, centers_veg, N_cores)
plot(centers_veg$x*rescale, centers_veg$y*rescale, col='lightgrey')
points(centers_veg[idx_cores,'x']*rescale, centers_veg[idx_cores,'y']*rescale, col='red', pch=19)
points(centers_pol$x*rescale, centers_pol$y*rescale, col='blue', pch=4, cex=1.4)
plot(us.shp, add=TRUE)
# check domain splitting
idx_cores_all <- build_idx_cores(cbind(pollen_check$x, pollen_check$y), centers_veg, N_cores=nrow(pollen_check))
build_idx_cores
# check domain splitting
idx_cores_all <- build_idx_cores(cbind(pollen_check$x, pollen_check$y), centers_veg, N_cores=nrow(pollen_check))
d = rdist(centers_veg, centers_veg)
diag(d) <- 0
d_knots = rdist(knot_coords, knot_coords)
diag(d_knots) <- 0
d_inter = rdist(centers_veg, knot_coords)
d_inter[which(d_inter<1e-8)]=0
d_pol = rdist(centers_pol, centers_veg)
d_pol[which(d_pol<1e-8)]=0
N_knots = nrow(knot_coords)
##########################################################################################################################
## pull in calibration parameters
##########################################################################################################################
KW     = FALSE
KGAMMA = FALSE
kernel    = run$kernel
run
load("~/Documents/STEPPS-prediction-Ecology/data/calibration/cal_data_12taxa_mid_comp_ALL_v0.3.rdata")
run
kernel    = run$kernel
load("~/Documents/STEPPS-prediction-Ecology/runs/input.rdata")
kernel    = run$kernel
rIts_sub <- readRDS("~/Documents/STEPPS-prediction-Ecology/runs/rIts_sub.RDS")
