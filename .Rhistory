convert   = read.table('data/dict-comp2stepps.csv', sep=',', row.names=1, header=TRUE)
# pls veg data
pls.raw = data.frame(read.table(file=path_pls, sep=",", row.names=1, header=TRUE))
# read in grid
#load(file=path_grid)
# pollen data
pollen_ts = read.table(path_pollen, header=TRUE, sep=',', stringsAsFactors=FALSE)
# FS - each lake has unique id and multiple bacon_draw#
pol_ids = data.frame(id=unique(pollen_ts$id), stat_id=seq(1, length(unique(pollen_ts$id))))
# if draw=TRUE then replace mean age_bacon with draw age_bacon
if (draw) {
all_files   = list.files(path_age_samples)
all_drawRDS = all_files[grep('draw', all_files)]
# FS - randomply choses one draw index
drawRDS     = all_drawRDS[sample(seq(1, length(all_drawRDS)), 1)]   # random sample from available posterior age draws
age_sample   = readRDS(file.path(path_age_samples, drawRDS))
# replace age_bacon with the draw
if (bchron){
pollen_ts$age_bchron = age_sample
} else {
pollen_ts$age_bacon  = age_sample
}
}
bchron = FALSE
if (bchron){
pollen_ts = pollen_ts[!is.na(pollen_ts$age_bchron),]
} else {
pollen_ts = pollen_ts[!is.na(pollen_ts$age_bacon),]
}
pollen_ts <- pollen_ts %>% select(-c(NEOTOMA.1, PALEON.STEPPS, TOTAL_POLLEN))
#order collumns right:
pollen_ts <- pollen_ts %>%
select(
id, sitename, lat, long, state, altitude,
age_bacon,
starts_with("bacon_"),
depth, ASH,
everything()
)
# max_ages
if (constrain){
if (bchron){
max_ages = read.table(file='data/pol_ages_bchron_6.csv', sep=',', header=TRUE)
} else {
max_ages = read.table(file='data/pol_ages_v6.csv', sep=',', header=TRUE)
}
drop_samples = constrain_pollen(pollen_ts, max_ages, nbeyond=nbeyond)
if (add_varves){
vids = c(2309, 14839, 3131)
drop_samples[which(pollen_ts$id %in% vids)] = FALSE
}
pollen_ts = pollen_ts[!drop_samples,]
}
cal_fit = rstan::read_stan_csv(path_cal)
# read in veg data and output
# veg data specifies which knots to use
load(path_veg_data)
veg_post = readRDS(file=path_veg_pars)
# load(file=path_veg_pars)
# veg_post = post
##########################################################################################################################
## read in and organize pls data
##########################################################################################################################
# changes taxa names to lower case
colnames(pls.raw) = tolower(colnames(pls.raw))
# pull the subset of proportions
taxa.start.col = min(match(tolower(rownames(convert)), colnames(pls.raw)), na.rm=TRUE)
# # might need to fix this later, doesn't work with updated data but don't need it now
# if (any(!(tolower(sort(taxa)) == sort(colnames(pls_dat))))) {
#   pls_dat  = pls.raw[,taxa.start.col:ncol(pls.raw)]
#   colnames(pls_dat) = as.vector(convert[match(colnames(pls_dat), tolower(rownames(convert))),1])
#   pls_dat_collapse  = sapply(unique(colnames(pls_dat)),
#                              function(x) rowSums( pls_dat[ , grep(x, names(pls_dat)), drop=FALSE]) )
#   counts = data.frame(pls_dat_collapse[,sort(colnames(pls_dat_collapse))])
# }
# FS - raw pollen couts for each taxa
counts = pls.raw[,taxa.start.col:ncol(pls.raw)]
# FS - geographical location of each count
meta   = pls.raw[,1:(taxa.start.col-1)]
# kilometers
# pls$X = pls$X/1000
# pls$Y = pls$Y/1000
# FS - use the new function
# create collumns state (minnesota, south dakatoa, north dakota, iowa, na, wiconsin, michigan:north, illinois, michigan:south, indiana, ohio)
# and state2 (minnesota, wisconsin, michigan:north, and michigan:south) the corrected map look up
meta        = split_mi(meta)
library(fields)
library(rstan)
library(sp)
#library(rgdal)
library(tidyr)
library(dplyr)
library(ggplot2)
library(mvtnorm)
#library(maptools)
library(maps)
library(plyr)
# FS - use the new function
# create collumns state (minnesota, south dakatoa, north dakota, iowa, na, wiconsin, michigan:north, illinois, michigan:south, indiana, ohio)
# and state2 (minnesota, wisconsin, michigan:north, and michigan:south) the corrected map look up
meta        = split_mi(meta)
# only keep counts/meta that are in the corrected "minnesota" "wisconsin" "michigan:north" (states_pls)
counts      = counts[which(meta$state2 %in% states_pls),]
meta        = meta[which(meta$state2 %in% states_pls),]
centers_pls = data.frame(x=meta$x, y=meta$y)/rescale # megameters!
centers_pls
# FS - Corrected for SP object; checks that seperated out the correct uppermidwest cells
# plot(centers_pls[,1]*rescale, centers_pls[,2]*rescale, asp=1, axes=F,  col='antiquewhite4', xlab='',ylab='', pch=19, cex=0.2) # old code
# plot(us.shp, add=T) # old code
# plots center of pls grid cells (8 km x 8 km)
plot(centers_pls[,1] * rescale,
centers_pls[,2] * rescale,
asp = 1,
axes = FALSE,
col = "antiquewhite4",
pch = 19,
cex = 0.2)
# adds borders
plot(st_geometry(us.shp), add = TRUE, border = "black", lwd = 0.5)
# FS - aggreg raw pollen count data into 12 taxa (including OTHER group)
y_veg = convert_counts(counts, tree_type, taxa_sub)
# FS - removes collumn names, creating counts as ordered matrix
taxa = colnames(y_veg)
y_veg = as.matrix(round(unname(y_veg)))
rownames(y_veg) = NULL
y_veg = unname(y_veg)
K = as.integer(ncol(y_veg))
W = K-1
N_pls = nrow(y_veg)
# FS - created domain of uppermidwest form PLS grid centers
states_pls <- c("wisconsin", "michigan:north","minnesota")
domain <- meta[meta$state2 %in% states_pls, c("x", "y")]
# FIXME: ADD STATE TO GRID
# coarse_domain  = coarse_domain[coarse_domain$state %in% states_pls,]
coarse_centers = domain[,1:2]
# check domain working with
plot(coarse_centers[,1] * rescale,
coarse_centers[,2] * rescale,
col = "blue",
pch = 19,
cex = 0.3,
asp = 1,
axes = FALSE,
xlab = "",
ylab = "")
plot(st_geometry(us.shp), add = TRUE, border = "black")
# assign grid to centers_veg
centers_veg = coarse_centers
N = nrow(centers_veg)
# subdomain boundaries
xlo = min(centers_veg$x)
xhi = max(centers_veg$x)
ylo = min(centers_veg$y)
yhi = max(centers_veg$y)
saveRDS(pollen_ts, file='data/pollen_ts.RDS')
# FS - only keep sites in "minnesota"      "wisconsin"      "michigan:north"
pollen_ts1 = pollen_ts[which(pollen_ts$state %in% states_pol),]
colnames(pollen_ts1)
# FS - had to edit this function to use sf instead (rerun pollen_to_albers.r file)
# reproject pollen coords from lat long to Albers
pollen_ts2 = pollen_to_albers(pollen_ts1)
# FS - location of pollen
pollen_locs = cbind(pollen_ts2$x, pollen_ts2$y)
# FS - checks that the pollen sitees are within the vegetation domain
plot(centers_veg$x, centers_veg$y, col='green', pch=19, main='Vegetation vs Pollen')
points(pollen_locs[,1], pollen_locs[,2], col='red', pch=19)
points(pollen_locs[,1], pollen_locs[,2], col='red', pch=19)
pollen_locs
pollen_locs
# FS - checks that the pollen sitees are within the vegetation domain
plot(centers_veg$x, centers_veg$y, col='green', pch=19, main='Vegetation vs Pollen')
points(pollen_locs[,1], pollen_locs[,2], col='red', pch=19)
pollen_locs
pollen_locs[,1]
pollen_locs[,2]
colnames(pollen_ts1)
pollen_ts1
# FS - had to edit this function to use sf instead (rerun pollen_to_albers.r file)
# reproject pollen coords from lat long to Albers
pollen_ts2 = pollen_to_albers(pollen_ts1)
pollen_to_albers <- function(pollen_ts) {
library(sp)
# Remove rows with missing coordinates
pollen_ts <- pollen_ts[!is.na(pollen_ts$lat) & !is.na(pollen_ts$long), ]
if(nrow(pollen_ts) == 0) stop("No valid coordinates to transform.")
centers_pol <- data.frame(x = pollen_ts$long, y = pollen_ts$lat)
coordinates(centers_pol) <- ~ x + y
proj4string(centers_pol) <- CRS("+proj=longlat +datum=WGS84 +no_defs")
centers_polA <- spTransform(centers_pol, CRS(SRS_string = "EPSG:3175"))
centers_polA_df <- as.data.frame(centers_polA)
colnames(centers_polA_df) <- c("x", "y")
pollen_ts$x <- centers_polA_df$x
pollen_ts$y <- centers_polA_df$y
return(pollen_ts)
}
# FS - had to edit this function to use sf instead (rerun pollen_to_albers.r file)
# reproject pollen coords from lat long to Albers
pollen_ts2 = pollen_to_albers(pollen_ts1)
# FS - location of pollen
pollen_locs = cbind(pollen_ts2$x, pollen_ts2$y)
# FS - checks that the pollen sitees are within the vegetation domain
plot(centers_veg$x, centers_veg$y, col='green', pch=19, main='Vegetation vs Pollen')
points(pollen_locs[,1], pollen_locs[,2], col='red', pch=19)
# FS - FIX ME - currently no matches ie no cores in the domain
#pollen_int  = cores_near_domain(pollen_locs, centers_veg, cell_width = res*8000/rescale)
cell_width_value <- 8000   #  FS - changed!!!!
pollen_int <- cores_near_domain(pollen_locs, centers_veg, cell_width = cell_width_value)
# FS - Keep only pollen points that exactly match the coordinates in pollen_int
# FS - idx_pollen_int is a logical vector used to filter pollen_ts2 to these points
idx_pollen_int = apply(pollen_locs, 1,
function(x) if (any(rdist(x, pollen_int) < 1e-8)) {return(TRUE)} else {return(FALSE)})
pollen_ts3 = pollen_ts2[idx_pollen_int, ]
pollen_ts3
View()
View(pollen_ts3)
# FS - plot domain and core locations in Wisconsin, upper michican, and minnesota
par(mfrow=c(1,1))
plot(centers_veg$x*rescale, centers_veg$y*rescale)
points(pollen_ts3$x*rescale, pollen_ts3$y*rescale, col='blue', pch=19)
plot(us.shp, add=T, lwd=2)
##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - Moved x and y columns to front so that they aren't lost in build_pollen_counts function
pollen_ts3 <- pollen_ts3[, c("id", "x", "y", setdiff(colnames(pollen_ts3), c("id","x","y")))]
# sum counts over int length intervals,
int = 20
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
colnames(pollen_ts3)
str(pollen_ts3)
build_pollen_counts()
build_pollen_counts
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
c
build_pollen_counts <- function(tmin, tmax, int,
pollen_ts,
taxa_all,
taxa_sub,
age_model) {
## ---- choose age column ----
if (age_model == "bacon") {
age_col <- "age_bacon"
} else if (age_model == "bchron") {
age_col <- "age_bchron"
} else {
age_col <- "age_default"
}
## ---- find first taxa column ----
taxa.start.col <- min(match(taxa_all, colnames(pollen_ts)), na.rm = TRUE)
## ---- subset to time window ----
keep <- pollen_ts[, age_col] >= tmin & pollen_ts[, age_col] <= tmax
pollen_sub <- pollen_ts[keep, , drop = FALSE]
meta_pol <- pollen_sub[, 1:(taxa.start.col - 1), drop = FALSE]
counts   <- pollen_sub[, taxa.start.col:ncol(pollen_sub), drop = FALSE]
## add age placeholder
meta_pol$age <- NA_real_
## ---- bin breaks ----
breaks <- seq(tmin, tmax, by = int)
## ---- initialize outputs (DATA FRAMES ONLY) ----
counts_agg <- counts[0, ]
meta_agg <- data.frame(
meta_pol[0, 1:6],
age  = numeric(0),
zero = logical(0)
)
meta_all <- meta_pol[0, ]
## ---- loop over cores ----
ids <- unique(meta_pol$id)
for (i in seq_along(ids)) {
message("core ", i)
core_rows <- which(meta_pol$id == ids[i])
for (j in seq_len(length(breaks) - 1)) {
age_mid <- breaks[j] + int / 2
age_rows <- core_rows[
meta_pol[core_rows, age_col] >= breaks[j] &
meta_pol[core_rows, age_col] <  breaks[j + 1]
]
## ---- cases ----
if (length(age_rows) > 1) {
counts_row <- as.data.frame(
t(colSums(counts[age_rows, , drop = FALSE]))
)
meta_row <- data.frame(
meta_pol[age_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else if (length(age_rows) == 1) {
counts_row <- counts[age_rows, , drop = FALSE]
meta_row <- data.frame(
meta_pol[age_rows, 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else {
counts_row <- as.data.frame(
t(rep(0, ncol(counts)))
)
colnames(counts_row) <- colnames(counts)
meta_row <- data.frame(
meta_pol[core_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = TRUE
)
meta_all_rows <- meta_pol[core_rows[1], , drop = FALSE]
meta_all_rows$age <- NA_real_
}
## ---- bind ----
counts_agg <- rbind(counts_agg, counts_row)
meta_agg   <- rbind(meta_agg, meta_row)
meta_all   <- rbind(meta_all, meta_all_rows)
}
}
return(list(
counts_agg = counts_agg,
meta_agg   = meta_agg,
meta_all   = meta_all
))
}
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
# tells when summing each core
message("core ", i, sitename)
build_pollen_counts <- function(tmin, tmax, int,
pollen_ts,
taxa_all,
taxa_sub,
age_model) {
## ---- choose age column ----
if (age_model == "bacon") {
age_col <- "age_bacon"
} else if (age_model == "bchron") {
age_col <- "age_bchron"
} else {
age_col <- "age_default"
}
## ---- find first taxa column ----
taxa.start.col <- min(match(taxa_all, colnames(pollen_ts)), na.rm = TRUE)
## ---- subset to time window (int) ----
keep <- pollen_ts[, age_col] >= tmin & pollen_ts[, age_col] <= tmax
pollen_sub <- pollen_ts[keep, , drop = FALSE]
meta_pol <- pollen_sub[, 1:(taxa.start.col - 1), drop = FALSE]
counts   <- pollen_sub[, taxa.start.col:ncol(pollen_sub), drop = FALSE]
## add age placeholder
meta_pol$age <- NA_real_
## ---- bin breaks ----
breaks <- seq(tmin, tmax, by = int)
## ---- initialize outputs (DATA FRAMES ONLY) ----
counts_agg <- counts[0, ]
meta_agg <- data.frame(
meta_pol[0, 1:6],
age  = numeric(0),
zero = logical(0)
)
meta_all <- meta_pol[0, ]
## ---- loop over cores ----
ids <- unique(meta_pol$id)
for (i in seq_along(ids)) {
# tells when summing each core
message("core ", i, sitename)
core_rows <- which(meta_pol$id == ids[i])
for (j in seq_len(length(breaks) - 1)) {
age_mid <- breaks[j] + int / 2
age_rows <- core_rows[
meta_pol[core_rows, age_col] >= breaks[j] &
meta_pol[core_rows, age_col] <  breaks[j + 1]
]
## ---- cases ----
if (length(age_rows) > 1) {
counts_row <- as.data.frame(
t(colSums(counts[age_rows, , drop = FALSE]))
)
meta_row <- data.frame(
meta_pol[age_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else if (length(age_rows) == 1) {
counts_row <- counts[age_rows, , drop = FALSE]
meta_row <- data.frame(
meta_pol[age_rows, 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else {
counts_row <- as.data.frame(
t(rep(0, ncol(counts)))
)
colnames(counts_row) <- colnames(counts)
meta_row <- data.frame(
meta_pol[core_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = TRUE
)
meta_all_rows <- meta_pol[core_rows[1], , drop = FALSE]
meta_all_rows$age <- NA_real_
}
## ---- bind ----
counts_agg <- rbind(counts_agg, counts_row)
meta_agg   <- rbind(meta_agg, meta_row)
meta_all   <- rbind(meta_all, meta_all_rows)
}
}
return(list(
counts_agg = counts_agg,
meta_agg   = meta_agg,
meta_all   = meta_all
))
}
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
build_pollen_counts <- function(tmin, tmax, int,
pollen_ts,
taxa_all,
taxa_sub,
age_model) {
## ---- choose age column ----
if (age_model == "bacon") {
age_col <- "age_bacon"
} else if (age_model == "bchron") {
age_col <- "age_bchron"
} else {
age_col <- "age_default"
}
## ---- find first taxa column ----
taxa.start.col <- min(match(taxa_all, colnames(pollen_ts)), na.rm = TRUE)
## ---- subset to time window (int) ----
keep <- pollen_ts[, age_col] >= tmin & pollen_ts[, age_col] <= tmax
pollen_sub <- pollen_ts[keep, , drop = FALSE]
meta_pol <- pollen_sub[, 1:(taxa.start.col - 1), drop = FALSE]
counts   <- pollen_sub[, taxa.start.col:ncol(pollen_sub), drop = FALSE]
## add age placeholder
meta_pol$age <- NA_real_
## ---- bin breaks ----
breaks <- seq(tmin, tmax, by = int)
## ---- initialize outputs (DATA FRAMES ONLY) ----
counts_agg <- counts[0, ]
meta_agg <- data.frame(
meta_pol[0, 1:6],
age  = numeric(0),
zero = logical(0)
)
meta_all <- meta_pol[0, ]
## ---- loop over cores ----
ids <- unique(meta_pol$id)
for (i in seq_along(ids)) {
# tells when summing each core
message("core ", i)
core_rows <- which(meta_pol$id == ids[i])
for (j in seq_len(length(breaks) - 1)) {
age_mid <- breaks[j] + int / 2
age_rows <- core_rows[
meta_pol[core_rows, age_col] >= breaks[j] &
meta_pol[core_rows, age_col] <  breaks[j + 1]
]
## ---- cases ----
if (length(age_rows) > 1) {
counts_row <- as.data.frame(
t(colSums(counts[age_rows, , drop = FALSE]))
)
meta_row <- data.frame(
meta_pol[age_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else if (length(age_rows) == 1) {
counts_row <- counts[age_rows, , drop = FALSE]
meta_row <- data.frame(
meta_pol[age_rows, 1:6, drop = FALSE],
age  = age_mid / 100,
zero = FALSE
)
meta_all_rows <- meta_pol[age_rows, , drop = FALSE]
meta_all_rows$age <- age_mid / 100
} else {
counts_row <- as.data.frame(
t(rep(0, ncol(counts)))
)
colnames(counts_row) <- colnames(counts)
meta_row <- data.frame(
meta_pol[core_rows[1], 1:6, drop = FALSE],
age  = age_mid / 100,
zero = TRUE
)
meta_all_rows <- meta_pol[core_rows[1], , drop = FALSE]
meta_all_rows$age <- NA_real_
}
## ---- bind ----
counts_agg <- rbind(counts_agg, counts_row)
meta_agg   <- rbind(meta_agg, meta_row)
meta_all   <- rbind(meta_all, meta_all_rows)
}
}
return(list(
counts_agg = counts_agg,
meta_agg   = meta_agg,
meta_all   = meta_all
))
}
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
View(pollen_agg)
View(pollen_agg$counts_agg)
View(pollen_agg$meta_agg)
View(pollen_agg$meta_all)
