##########################################################################################################################
## chunk: prepare pollen data; aggregate over time intervals
##########################################################################################################################
# FS - Moved x and y columns to front so that they aren't lost in build_pollen_counts function
pollen_ts3 <- pollen_ts3[, c("id", "x", "y", setdiff(colnames(pollen_ts3), c("id","x","y")))]
# sum counts over time interval length intervals
pollen_agg = build_pollen_counts(tmin=tmin, tmax=tmax, int=int, pollen_ts=pollen_ts3, taxa_all, taxa_sub, age_model=age_model)
age
pollen_agg
meta_pol_all = pollen_agg[[3]]
meta_pol   = pollen_agg[[2]]
counts     = pollen_agg[[1]]
counts
meta_pol
meta_pol$stat_id = pol_ids$stat_id[match(meta_pol$id, pol_ids$id)]
meta_pol_all$stat_id = pol_ids$stat_id[match(meta_pol_all$id, pol_ids$id)]
pollen_ts$stat_id = pol_ids$stat[match(pollen_ts$id, pol_ids$id)]
ages    = unique(sort(meta_pol$age)) # FS - only 21, each = 100 years
T       = length(ages)
if (one_time) {
lag = 0
} else {
lag     = unname(as.matrix(dist(matrix(ages), upper=TRUE)))
}
N_cores = length(unique(meta_pol$id)) # FS - 199
y = convert_counts(counts, tree_type, taxa_sub)
# make sure columns match!
if (sum(colnames(y) %in% taxa) != K){
print('The number of taxa wanted does not match the number of taxa in the data frame! Name mismatch likely.')
}
# y = y[,taxa]
y = unname(y)
centers_pol = data.frame(x=numeric(N_cores), y=numeric(N_cores))
for (i in 1:N_cores){
id = unique(meta_pol$id)[i]
idx = min(which(meta_pol$id == id))
print(idx)
centers_pol[i,] = c(meta_pol$x[idx], meta_pol$y[idx])
}
# indices for which cells the cores fall in
idx_cores <- build_idx_cores(centers_pol, centers_veg, N_cores)
plot(centers_veg$x*rescale, centers_veg$y*rescale, col='lightgrey')
points(centers_veg[idx_cores,'x']*rescale, centers_veg[idx_cores,'y']*rescale, col='red', pch=19)
points(centers_pol$x*rescale, centers_pol$y*rescale, col='blue', pch=4, cex=1.4)
plot(us.shp, add=TRUE)
c##########################################################################################################################
d = rdist(centers_veg, centers_veg)
diag(d) <- 0
d_knots = rdist(knot_coords, knot_coords)
diag(d_knots) <- 0
d_inter = rdist(centers_veg, knot_coords)
d_inter[which(d_inter<1e-8)]=0
d_pol = rdist(centers_pol, centers_veg)
d_pol[which(d_pol<1e-8)]=0
N_knots = nrow(knot_coords)
KW     = FALSE
KGAMMA = FALSE
# kernel    = run$kernel
# FS -  to check that there is only one kernel object
kernel <- sapply(runs, function(x) x$kernel)
cal_post      = rstan::extract(cal_fit, permuted=FALSE, inc_warmup=FALSE)
col_names = colnames(cal_post[,1,])
par_names  = unlist(lapply(col_names, function(x) strsplit(x, "\\[")[[1]][1]))
if (draw) {
draw_cal = sample(seq(1, dim(cal_post)[1]), 1)
cal_post     = cal_post[draw_cal,1,]
} else {
cal_post = colMeans(cal_post[,1,])
}
phi = unname(cal_post[which(par_names == 'phi')][1:K])
one_gamma = sapply(runs, function(x) x$one_gamma)
if (one_gamma){
gamma = unname(cal_post[which(par_names == 'gamma')])
} else {
KGAMMA = TRUE
gamma  = unname(cal_post[which(par_names == 'gamma')][1:K])
}
if (kernel=='pl'){
# FS
# one_a = runs$one_a
one_a = sapply(runs, function(x) x$one_a)
if (one_a){
a = unname(cal_post[which(par_names == 'a')])
} else {
KW = TRUE
a = unname(cal_post[which(par_names == 'a')][1:K])
}
# FS
# one_b = runs$one_b
one_b = sapply(runs, function(x) x$one_b)
if (one_b){
b = unname(cal_post[which(par_names == 'b')])
} else {
KW = TRUE
b = unname(cal_post[which(par_names == 'b')][1:K])
}
}
# FS - changed since runs appears to have multiple layers
# create the weighting matrix for pollen dispersion for each of the 12 taxa groups
w <- build_weight_matrix(cal_post, d_pol, idx_cores, N, N_cores, runs[[1]])
coord_pot = seq(-700000, 700000, by=8000)
w
idx_cores
N
coord_pot = seq(-700000, 700000, by=8000)
coord_pot = expand.grid(coord_pot, coord_pot)
d_pot = t(rdist(matrix(c(0,0), ncol=2), as.matrix(coord_pot, ncol=2))/rescale)
d_pot = unname(as.matrix(count(data.frame(d_pot))))
N_pot     = nrow(d_pot)
sum_w_pot = build_sumw_pot(cal_post, K, N_pot, d_pot, runs[[1]])
build_sumw_pot
# Function to calculate the total potential neighborhood weighting
# Used to determine the normalization constant for the non-local contribution
build_sumw_pot <- function(post, K, N_pot, d_pot, run){
# Remove rows where the distance is effectively zero (to avoid self-weight at the origin)
d_pot = d_pot[!(d_pot[,1] < 1e-8), ]
# KW flag indicates whether we need a weight per taxa (TRUE → multiple weights)
KW = FALSE
# Identify which kernel to use: "gaussian" or "pl" (power-law)
kernel = run$kernel
# Extract base parameter names from the posterior (strip indices like [1])
par_names  = unlist(lapply(names(post), function(x) strsplit(x, "\\[")[[1]][1]))
# -------------------------------
# Gaussian kernel
# -------------------------------
if (kernel=='gaussian'){
one_psi = run$one_psi  # flag: is psi shared across all taxa?
if (one_psi){
# single psi value used for all taxa
psi = post[which(par_names == 'psi')]
} else {
# different psi per taxa → need KW = TRUE
KW  = TRUE
psi = post[which(par_names == 'psi')]
}
if (KW){
# Compute sum of weighted contributions for each taxa separately
sum_w = rep(NA, K)
for (k in 1:K)
# sum over all potential distances, weighted by number of points at that distance
sum_w[k] = sum(d_pot[,2] * exp(-d_pot[,1]^2 / psi[k]^2))
} else {
# single psi for all taxa → sum once
sum_w = sum(d_pot[,2] * exp(-d_pot[,1]^2 / psi^2))
}
# -------------------------------
# Power-law kernel
# -------------------------------
} else if (kernel=='pl'){
one_a = run$one_a  # flag: is a (range) shared across taxa?
one_b = run$one_b  # flag: is b (shape) shared across taxa?
# Handle 'a' parameter
if (one_a){
a = post[which(par_names == 'a')]
} else {
KW = TRUE
a = post[which(par_names == 'a')]
}
# Handle 'b' parameter
if (one_b){
b = post[which(par_names == 'b')]
# If multiple 'a's, replicate 'b' to match K
if (KW) b = rep(b, K)
} else {
KW = TRUE
b  = post[which(par_names == 'b')]
}
if (KW){
# compute sum of weighted contributions for each taxa separately
sum_w = rep(NA, K)
for (k in 1:K)
sum_w[k] = sum( d_pot[,2] *
(b[k]-1) * (b[k]-2) / (2 * pi * a[k]^2) *
(1 + d_pot[,1] / a[k])^(-b[k]) )
} else {
# single a,b → sum once
sum_w = sum( d_pot[,2] *
(b-1) * (b-2) / (2 * pi * a^2) *
(1 + d_pot[,1] / a)^(-b) )
}
}
# Return the normalization constant(s)
return(sum_w)
}
# Function to calculate the total potential neighborhood weighting
# Used to determine the normalization constant for the non-local contribution
build_sumw_pot <- function(post, K, N_pot, d_pot, run){
# Remove rows where the distance is effectively zero (to avoid self-weight at the origin)
d_pot = d_pot[!(d_pot[,1] < 1e-8), ]
# KW flag indicates whether we need a weight per taxa (TRUE → multiple weights)
KW = FALSE
# Identify which kernel to use: "gaussian" or "pl" (power-law)
kernel = run$kernel
# Extract base parameter names from the posterior (strip indices like [1])
par_names  = unlist(lapply(names(post), function(x) strsplit(x, "\\[")[[1]][1]))
# -------------------------------
# Gaussian kernel
# -------------------------------
if (kernel=='gaussian'){
one_psi = run$one_psi  # flag: is psi shared across all taxa?
if (one_psi){
# single psi value used for all taxa
psi = post[which(par_names == 'psi')]
} else {
# different psi per taxa → need KW = TRUE
KW  = TRUE
psi = post[which(par_names == 'psi')]
}
if (KW){
# Compute sum of weighted contributions for each taxa separately
sum_w = rep(NA, K)
for (k in 1:K)
# sum over all potential distances, weighted by number of points at that distance
sum_w[k] = sum(d_pot[,2] * exp(-d_pot[,1]^2 / psi[k]^2))
} else {
# single psi for all taxa → sum once
sum_w = sum(d_pot[,2] * exp(-d_pot[,1]^2 / psi^2))
}
# -------------------------------
# Power-law kernel
# -------------------------------
} else if (kernel=='pl'){
one_a = run$one_a  # flag: is a (range) shared across taxa?
one_b = run$one_b  # flag: is b (shape) shared across taxa?
# Handle 'a' parameter
if (one_a){
a = post[which(par_names == 'a')]
} else {
KW = TRUE
a = post[which(par_names == 'a')]
}
# Handle 'b' parameter
if (one_b){
b = post[which(par_names == 'b')]
# If multiple 'a's, replicate 'b' to match K
if (KW) b = rep(b, K)
} else {
KW = TRUE
b  = post[which(par_names == 'b')]
}
if (KW){
# compute sum of weighted contributions for each taxa separately
sum_w = rep(NA, K)
for (k in 1:K)
sum_w[k] = sum( d_pot[,2] *
(b[k]-1) * (b[k]-2) / (2 * pi * a[k]^2) *
(1 + d_pot[,1] / a[k])^(-b[k]) )
} else {
# single a,b → sum once
sum_w = sum( d_pot[,2] *
(b-1) * (b-2) / (2 * pi * a^2) *
(1 + d_pot[,1] / a)^(-b) )
}
}
# Return the normalization constant(s)
return(sum_w)
}
runs$one_a
if (kernel=='pl'){
# FS
# one_a = runs$one_a
one_a = sapply(runs, function(x) x$one_a)
if (one_a){
a = unname(cal_post[which(par_names == 'a')])
} else {
KW = TRUE
a = unname(cal_post[which(par_names == 'a')][1:K])
}
# FS
# one_b = runs$one_b
one_b = sapply(runs, function(x) x$one_b)
if (one_b){
b = unname(cal_post[which(par_names == 'b')])
} else {
KW = TRUE
b = unname(cal_post[which(par_names == 'b')][1:K])
}
}
one_b
cal_post
N_pot     = nrow(d_pot)
N_pot
d
knot_coords
d_inter = rdist(centers_veg, knot_coords)
d_inter[which(d_inter<1e-8)]=0
d_inter
# kernel    = run$kernel
# FS -  to check that there is only one kernel object
kernel <- sapply(runs, function(x) x$kernel)
cal_post      = rstan::extract(cal_fit, permuted=FALSE, inc_warmup=FALSE)
cal_post
colnames(cal_post)
rownames(cal_post)
head(cal_post)
str(cal_post)
cal_post$parameters
cal_post[[parameters]]
col_names = colnames(cal_post[,1,])
col_names
par_names  = unlist(lapply(col_names, function(x) strsplit(x, "\\[")[[1]][1]))
unique(col_names)
#####################################################################################
# veg run pars
#####################################################################################
par_names = sapply(strsplit(colnames(veg_post), '\\.'), function(x) x[[1]])
w_coarse  = build_sumw_pot(cal_post, K, length(d_hood), cbind(t(d_hood), rep(1, length(d_hood))), run)
c##########################################################################################################################
## chunk 3: build distance matrices
##########################################################################################################################
# matrix between all possible begetation squares
d = rdist(centers_veg, centers_veg)
diag(d) <- 0
d_knots = rdist(knot_coords, knot_coords)
diag(d_knots) <- 0
d_inter = rdist(centers_veg, knot_coords)
d_inter[which(d_inter<1e-8)]=0
d_pol = rdist(centers_pol, centers_veg)
d_pol[which(d_pol<1e-8)]=0
N_knots = nrow(knot_coords)
##########################################################################################################################
## pull in calibration parameters
##########################################################################################################################
KW     = FALSE
KGAMMA = FALSE
# kernel    = run$kernel
# FS -  to check that there is only one kernel object
kernel <- sapply(runs, function(x) x$kernel)
# phi = differential production
# gamma = proportion of that cores pollen the given taxa producted in the grid cell
# Log_a, mu_gamma, sigma_gamma,b, a, not sure...
cal_post      = rstan::extract(cal_fit, permuted=FALSE, inc_warmup=FALSE)
col_names = colnames(cal_post[,1,])
par_names  = unlist(lapply(col_names, function(x) strsplit(x, "\\[")[[1]][1]))
if (draw) {
draw_cal = sample(seq(1, dim(cal_post)[1]), 1)
cal_post     = cal_post[draw_cal,1,]
} else {
cal_post = colMeans(cal_post[,1,])
}
phi = unname(cal_post[which(par_names == 'phi')][1:K])
one_gamma = sapply(runs, function(x) x$one_gamma)
if (one_gamma){
gamma = unname(cal_post[which(par_names == 'gamma')])
} else {
KGAMMA = TRUE
gamma  = unname(cal_post[which(par_names == 'gamma')][1:K])
}
if (kernel=='pl'){
# FS
# one_a = runs$one_a
one_a = sapply(runs, function(x) x$one_a)
if (one_a){
a = unname(cal_post[which(par_names == 'a')])
} else {
KW = TRUE
a = unname(cal_post[which(par_names == 'a')][1:K])
}
# FS
# one_b = runs$one_b
one_b = sapply(runs, function(x) x$one_b)
if (one_b){
b = unname(cal_post[which(par_names == 'b')])
} else {
KW = TRUE
b = unname(cal_post[which(par_names == 'b')][1:K])
}
}
# FS - START HERE 1/15/2025 - Check more what this function does
# FS - changed since runs appears to have multiple layers
# create the weighting matrix for pollen dispersion for each of the 12 taxa groups
w <- build_weight_matrix(cal_post, d_pol, idx_cores, N, N_cores, runs[[1]])
#####################################################################################
# calculate potential d
# used to determine C normalizing constant in the non-local contribution term
#####################################################################################
coord_pot = seq(-700000, 700000, by=8000)
coord_pot = expand.grid(coord_pot, coord_pot)
d_pot = t(rdist(matrix(c(0,0), ncol=2), as.matrix(coord_pot, ncol=2))/rescale)
d_pot = unname(as.matrix(count(data.frame(d_pot))))
N_pot     = nrow(d_pot)
#####################################################################################
# recompute gamma; needed to account for change in resolution from base res
#####################################################################################
w_coarse  = build_sumw_pot(cal_post, K, length(d_hood), cbind(t(d_hood), rep(1, length(d_hood))), run)
gamma_new = recompute_gamma(w_coarse, sum_w_pot, gamma)
w_coarse  = build_sumw_pot(cal_post, K, length(d_pot), cbind(t(d_pot), rep(1, length(d_pot))), run)
build_sumw_pot
w_coarse  = build_sumw_pot(cal_post, K, length(d_hood), cbind(t(d_hood), rep(1, length(d_hood))), run)
w_coarse  = build_sumw_pot(cal_post, K, length(d_pot), cbind(t(d_pot), rep(1, length(d_pot))), run)
#####################################################################################
# veg run pars
#####################################################################################
par_names = sapply(strsplit(colnames(veg_post), '\\.'), function(x) x[[1]])
eta = veg_post[,which(par_names == 'eta')]
rho = veg_post[,which(par_names == 'rho')]
#####################################################################################
# veg run pars
#####################################################################################
par_names = sapply(strsplit(colnames(veg_post), '\\.'), function(x) x[[1]])
eta = veg_post[,which(par_names == 'eta')]
rho = veg_post[,which(par_names == 'rho')]
if (draw){
iter = sample(seq(1,nrow(veg_post)), 1)
eta = eta[iter,]
rho = rho[iter,]
} else {
eta = colMeans(eta)
rho = colMeans(rho)
}
eta = unname(eta)[1:K]
rho = unname(rho)[1:K]
##########################################################################################################################
## save the data; rdata more efficient, use for processing
##########################################################################################################################
if (kernel == 'gaussian'){ suff = paste0('G_', suff) } else if (kernel == 'pl'){suff = paste0('PL_', suff)}
if (!draw) suff = paste0(suff, '_mean')
dirName = paste0('runs/', N_knots, 'knots_', tmin, 'to', tmax, 'ybp_', suff)
if (one_time){
dirName = paste0('runs/space_slices_', suff)
}
if (AR){
dirName = paste0(dirName, '_ar')
}
if (!(file.exists(dirName))) {
dir.create(dirName)
}
if (one_time){
subDir=paste0('slice', tmin, 'to', tmax)
if (!(file.exists(file.path(dirName, subDir)))) {
dir.create(file.path(dirName, subDir))
}
} else {
subDir=paste0('run', dr)
if (!(file.exists(file.path(dirName, subDir)))) {
dir.create(file.path(dirName, subDir))
}
}
fname = file.path(dirName, subDir, 'input')
# note that w is column-major
save(K, N, T, N_cores, N_knots, res,
gamma, phi, rho, eta,
y,
idx_cores,
d_knots, d_inter, w, #d_pol, #d,
lag,
#        P, N_p, sum_w_pot,
meta_pol, meta_pol_all,
sum_w_pot, pollen_check,
knot_coords,
centers_pls, centers_veg, centers_pol, taxa, ages, y_veg, N_pls,
file=paste0(fname, '.rdata'))
# note that w is column-major
save(K, N, T, N_cores, N_knots, res,
gamma, phi, rho, eta,
y,
idx_cores,
d_knots, d_inter, w, #d_pol, #d,
lag,
#        P, N_p, sum_w_pot,
meta_pol, meta_pol_all,
sum_w_pot,
#pollen_check, # FS - Doesn't exist still...
knot_coords,
centers_pls, centers_veg, centers_pol, taxa, ages, y_veg, N_pls,
file=paste0(fname, '.rdata'))
# convert to row-major
if (KW){
w_new = vector(length=0)
for (k in 1:K)
w_new = c(w_new, as.vector(w[k,,]))
w = array(w_new, c(K, N_cores, N))
}
dump(c('K', 'N', 'T', 'N_cores', 'N_knots', 'res',
'gamma', 'phi', 'rho', 'eta',
'y',
'idx_cores',
'd_knots', 'd_inter', 'w', #'d_pol', #'d',
'lag',
'sum_w_pot'),
file=paste0(fname, '.dump'))
if (dr==1){
paths = list(path_grid   = path_grid,
path_pls    = path_pls,
path_pollen = path_pollen,
path_ages  = path_ages,
path_cal    = path_cal,
path_veg_data = path_veg_data,
path_veg_pars = path_veg_pars)
conn=file(file.path(dirName, 'meta.txt'), 'wt')
write("## Path names", conn)
for (j in 1:length(paths)) {
write(paste0('## ', names(paths)[[j]], '=', paths[[j]]), conn)
}
close(con=conn)
}
path_ages
if (dr==1){
paths = list(path_grid   = path_grid,
path_pls    = path_pls,
path_pollen = path_pollen,
# path_ages  = path_ages,  # FS - Doesn't exist
path_cal    = path_cal,
path_veg_data = path_veg_data,
path_veg_pars = path_veg_pars)
conn=file(file.path(dirName, 'meta.txt'), 'wt')
write("## Path names", conn)
for (j in 1:length(paths)) {
write(paste0('## ', names(paths)[[j]], '=', paths[[j]]), conn)
}
close(con=conn)
}
